import json, openai, re

# Load rules
with open("rules.json", encoding="utf-8") as f:
    RULES = json.load(f)

def rule_id(idx: int) -> str:
    return f"R{idx+1:03d}"

BATCH_SIZE = 40

# Initial COBOL source code (fill in your original code)
cobol_source = """..."""  # Put your COBOL code here

client = openai.OpenAI()

all_step1_rows = []
all_v4a_patches = []

def parse_v4a_patches(output):
    """
    Extract all V4A patch blocks from the model output, returning a list of patch block strings.
    """
    patches = []
    current = []
    in_patch = False
    for line in output.splitlines():
        if line.strip().startswith("*** Update File:"):
            in_patch = True
            current = [line]
        elif in_patch and line.strip().startswith("*** End Patch"):
            current.append(line)
            patches.append('\n'.join(current))
            in_patch = False
        elif in_patch:
            current.append(line)
    return patches

def apply_v4a_patch_to_code(code, v4a_patch):
    """
    Apply a single V4A patch block to the COBOL code string (in memory).
    Only supports a single patch block per call.
    """
    # Extract the body of the patch between @@ and *** End Patch
    m = re.search(r'\*\*\* Update File:.*?\n@@[^\n]*\n(.*?)\*\*\* End Patch', v4a_patch, re.DOTALL)
    if not m:
        return code
    patch_body = m.group(1)
    lines = patch_body.splitlines()
    context_before, minus_lines, plus_lines, context_after = [], [], [], []
    phase = 'context_before'
    for l in lines:
        if l.startswith('-'):
            phase = 'minus'
            minus_lines.append(l[1:].lstrip())
        elif l.startswith('+'):
            phase = 'plus'
            plus_lines.append(l[1:].lstrip())
        elif l.strip() == '':
            continue
        elif phase == 'minus' or phase == 'plus':
            phase = 'context_after'
            context_after.append(l.lstrip())
        else:
            context_before.append(l.lstrip())

    # Find the matching original segment in the code
    src_lines = code.splitlines()
    for i in range(len(src_lines) - len(context_before + minus_lines + context_after) + 1):
        window = src_lines[i : i + len(context_before + minus_lines + context_after)]
        if (
            window[:len(context_before)] == context_before
            and window[len(context_before):len(context_before) + len(minus_lines)] == minus_lines
            and window[-len(context_after):] == context_after if context_after else True
        ):
            # Build the new segment to replace the old one
            new_block = context_before + plus_lines + context_after
            src_lines = src_lines[:i] + new_block + src_lines[i + len(context_before + minus_lines + context_after):]
            return '\n'.join(src_lines)
    print("[WARN] Could not apply V4A patch block. Patch:\n", v4a_patch)
    return code

for batch_start in range(0, len(RULES), BATCH_SIZE):
    batch_rules = RULES[batch_start:batch_start+BATCH_SIZE]
    batch_summary = "\n".join(
        f"[{rule_id(batch_start+j)}] {r['summary']}" for j, r in enumerate(batch_rules)
    )
    rules_text = "\n\n".join(
        f"[{rule_id(batch_start+j)}]\nContent: {r['content']}\nExample: {r['example']}"
        for j, r in enumerate(batch_rules)
    )

    # V4A patch format example in the user prompt
    user_prompt = (
        "Check the following COBOL source code according to ONLY the rules above.\n"
        "Output all violations in the following table format:\n"
        "| Line Number | Rule ID | Rule Description |\n"
        "| ------ | ----------- | ---------------- |\n"
        "For each correction, output a patch in the following V4A format (do not output explanations, only patches):\n"
        "*** Update File: main.cobol\n"
        "@@ \n"
        " IDENTIFICATION DIVISION.\n"
        "-PROGRAM-ID. OLDPROG.\n"
        "+PROGRAM-ID. NEWPROG.\n"
        " DATA DIVISION.\n"
        "*** End Patch\n"
        "Repeat this format for each correction, and do not provide the entire modified code.\n\n"
        f"{cobol_source}"
    )

    system_prompt = (
        "You are a COBOL code reviewer. In this task, only use the following coding rules for checking.\n"
        "Rule Summaries:\n"
        f"{batch_summary}\n\n"
        "Rule Details (with examples):\n"
        f"{rules_text}\n\n"
        "Always strictly refer to the rules above when identifying and explaining code violations."
    )

    resp = client.chat.completions.create(
        model="gpt-4o-2024-05-13",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
    )
    output = resp.choices[0].message.content

    # --- Parse Step1 Table (optional, keep as needed) ---
    step1_rows = []
    for line in output.splitlines():
        if line.strip().startswith("|") and not "------" in line:
            cols = [c.strip() for c in line.strip().split("|")[1:-1]]
            if len(cols) == 3 and cols[0].isdigit():
                step1_rows.append(tuple(cols))
    all_step1_rows.extend(step1_rows)

    # --- Parse and Apply V4A patches ---
    patch_blocks = parse_v4a_patches(output)
    for patch in patch_blocks:
        cobol_source = apply_v4a_patch_to_code(cobol_source, patch)
    all_v4a_patches.extend(patch_blocks)

# The final corrected COBOL code string
print("【Final Corrected COBOL Code】\n")
print(cobol_source)

print("\n【All V4A Patch Records】\n")
for patch in all_v4a_patches:
    print(patch)
    print("="*40)
